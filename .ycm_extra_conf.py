import os
from subprocess import Popen, PIPE
import re
import ycm_core

SOURCE_EXTENSIONS = ['.cpp', '.cxx', '.cc', '.c']
HEADER_EXTENSIONS = ['.h', '.hxx', '.hpp', '.hh']

# This youcompleteme config file should lie in the project root.
project_root = os.path.dirname(os.path.abspath(__file__))

# Flags used if no compilation database is found.
default_flags = [
    '-Wall',
    '-Wextra',
    '-std=c++11',
    '-I' + os.path.join(project_root, 'src'),
    '-I' + os.path.join(project_root, 'src', '3rd-party'),
    '-I' + os.path.join(project_root, 'build'),
]

def GetStandardIncludePaths():
    try:
        process = Popen(['clang', '-v', '-E', '-x', 'c++', '-'], stdin=PIPE, stdout=PIPE, stderr=PIPE)
        err = process.communicate()[1]
        match = re.search('#include <\.\.\.> search starts here:\n(.*)\nEnd of search list\.', err, re.DOTALL)
        return match.group(1).split()
    except:
        return []

# Compiling by the clang binary uses the correct default header search paths
# but compiling from libclang.so does not. Therefore, we add the right paths
# manually.
extra_flags = ['-I' + x for x in GetStandardIncludePaths()]

# CMake generates a json database inside the build directory.
compilation_database_folder = os.path.join(project_root, 'build')

if os.path.exists(compilation_database_folder):
    database = ycm_core.CompilationDatabase(compilation_database_folder)
else:
    database = None

def GetCompilationInfoForFile(filename):
    # The compilation_commands.json file generated by CMake does not have entries
    # for header files. So we do our best by asking the db for flags for a
    # corresponding source file, if any. If one exists, the flags for that file
    # should be good enough.
    basename, extension = os.path.splitext(filename)
    if extension in HEADER_EXTENSIONS:
        for extension in SOURCE_EXTENSIONS:
            replacement_file = basename + extension
            if os.path.exists(replacement_file):
                compilation_info = database.GetCompilationInfoForFile(replacement_file)
                if compilation_info.compiler_flags_:
                    return compilation_info
        return None
    return database.GetCompilationInfoForFile(filename)

def FlagsForFile(filename, **kwargs):
    flags = default_flags

    if database:
        compilation_info = GetCompilationInfoForFile(filename)
        if compilation_info:
            flags = list(compilation_info.compiler_flags_)

    return {
        'flags': flags + extra_flags,
        'do_cache': True
    }
